<!-- live.html v2 - fixed detection overlay clearing -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>PiCam Lite | Live</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="style.css?v=4" rel="stylesheet">
</head>
<body data-page="live">
  <header class="site-header">
    <h1>Live</h1>
    <p class="tagline">Local MJPEG stream from the Pi</p>
  </header>

  <nav class="site-nav" aria-label="Primary">
    <a href="index.html" data-link="home">Home</a>
    <a href="live.html" data-link="live">Live</a>
    <a href="photos.html" data-link="photos">Photos</a>
    <a href="replays.html" data-link="replays">Replays</a>
    <a href="heatmap.html" data-link="heatmap">Heatmap</a>
  </nav>

  <main id="live-main" class="container">
    <section class="live-layout">
      <div class="live-video-container">
        <div style="position:relative; display:inline-block;">
          <img id="stream" alt="Live stream or placeholder">
          <canvas id="detection-overlay" style="position:absolute; top:0; left:0; pointer-events:none;"></canvas>
        </div>
      </div>
      <div class="live-controls-sidebar">
        <div class="control-card">
          <h3>Capture Photo</h3>
          <p class="control-description">Take a snapshot of the current frame</p>
          <button id="capture" class="control-btn">ðŸ“· Capture</button>
        </div>
        
        <div class="control-card">
          <h3>Download Replay</h3>
          <p class="control-description">Save recent video footage</p>
          <select id="replaySeconds" class="replay-select">
            <option value="10">10 seconds</option>
            <option value="30" selected>30 seconds</option>
            <option value="60">1 minute</option>
            <option value="120">2 minutes</option>
            <option value="180">3 minutes</option>
            <option value="300">5 minutes</option>
          </select>
          <button id="replay" class="control-btn">ðŸŽ¬ Download</button>
        </div>
        
        <div id="events" class="status-display"></div>
      </div>
    </section>
  </main>

  <script>
    const streamImg = document.getElementById('stream')
    const captureBtn = document.getElementById('capture')
    const replayBtn = document.getElementById('replay')
    const replaySeconds = document.getElementById('replaySeconds')
    const eventsEl = document.getElementById('events')
    const canvas = document.getElementById('detection-overlay')
    const ctx = canvas.getContext('2d')
    
    // Sync canvas size with image
    streamImg.onload = function() {
      canvas.width = streamImg.width
      canvas.height = streamImg.height
    }

    // Try WebSocket feed first; fallback to MJPEG
    let ws
    try{
      ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws')
      ws.onmessage = (ev)=>{
        try{
          const m = JSON.parse(ev.data)
          if(m.type === 'frame'){
            streamImg.src = 'data:image/jpeg;base64,' + m.data
          } else if(m.type === 'event'){
            // Handle specific events
            if(m.name === 'replay_saved') {
              eventsEl.textContent = `âœ… Replay saved! (${m.duration}s) View on Replays page.`
              showToast(`Replay saved (${m.duration}s)`, 'success')
            } else if(m.name === 'photo_taken') {
              eventsEl.textContent = 'Photo captured: ' + m.path
            } else {
              eventsEl.textContent = JSON.stringify(m)
            }
          } else if(m.type === 'notification'){
            // Show toast notification
            showToast(m.message, m.severity || 'info')
          } else if(m.type === 'error'){
            // Show error messages
            eventsEl.textContent = 'âŒ ' + m.message
            showToast(m.message, 'error')
          } else if(m.type === 'detections'){
            // Draw bounding boxes - always called, even for empty detections
            drawDetections(m.detections)
          }
        }catch(e){ console.warn('ws parse', e) }
      }
      
    // Draw detection bounding boxes
    function drawDetections(detections) {
      // ALWAYS clear the canvas first
      ctx.clearRect(0, 0, canvas.width, canvas.height)
      
      // If no detections, we're done (canvas is now clear)
      if (!detections || detections.length === 0) {
        return
      }
      
      detections.forEach(det => {
        // bbox format is [x1, y1, x2, y2] (normalized 0-1)
        const [x1, y1, x2, y2] = det.bbox
        
        // Convert normalized coordinates to pixels
        const px = x1 * canvas.width
        const py = y1 * canvas.height
        const pw = (x2 - x1) * canvas.width
        const ph = (y2 - y1) * canvas.height
        
        // Color based on class
        const color = det.class === 'person' ? '#22d3ee' : '#f59e0b'
        
        // Draw bounding box
        ctx.strokeStyle = color
        ctx.lineWidth = 3
        ctx.strokeRect(px, py, pw, ph)
        
        // Draw label background
        const label = `${det.class} ${(det.confidence * 100).toFixed(0)}%`
        ctx.font = 'bold 14px system-ui'
        const metrics = ctx.measureText(label)
        const labelHeight = 20
        
        ctx.fillStyle = color
        ctx.fillRect(px, py - labelHeight, metrics.width + 10, labelHeight)
        
        // Draw label text
        ctx.fillStyle = '#000'
        ctx.fillText(label, px + 5, py - 5)
      })
    }
      
    // Toast notification function
    function showToast(message, severity = 'info') {
      const toast = document.createElement('div')
      toast.className = `toast toast-${severity}`
      toast.textContent = message
      
      document.body.appendChild(toast)
      
      // Trigger animation
      setTimeout(() => toast.classList.add('show'), 10)
      
      // Remove after 4 seconds
      setTimeout(() => {
        toast.classList.remove('show')
        setTimeout(() => toast.remove(), 300)
      }, 4000)
    }
      ws.onopen = ()=>{ 
        console.log('ws open - clearing canvas')
        ctx.clearRect(0, 0, canvas.width, canvas.height)
      }
      ws.onerror = ()=>{ console.log('ws error') }
      ws.onclose = ()=>{ 
        console.log('ws closed')
        ctx.clearRect(0, 0, canvas.width, canvas.height)
        streamImg.src = '/stream.mjpg' 
      }
    }catch(e){ streamImg.src = '/stream.mjpg' }

    captureBtn.onclick = async ()=>{
      captureBtn.disabled = true
      const r = await fetch('/api/photo', { method: 'POST' })
      const j = await r.json()
      eventsEl.textContent = 'Saved: ' + j.path
      captureBtn.disabled = false
    }

    replayBtn.onclick = async ()=>{
      const s = parseInt(replaySeconds.value)||30
      replayBtn.disabled = true
      eventsEl.textContent = 'Creating replay (encoding in background)...'
      try {
        const response = await fetch(`/api/replay?seconds=${s}`, { method: 'POST' })
        if (response.ok) {
          const data = await response.json()
          eventsEl.textContent = `Encoding ${data.seconds}s replay... Please wait.`
          // The replay_saved event via WebSocket will update this when done
        } else {
          eventsEl.textContent = 'Failed to create replay'
        }
      } catch (error) {
        eventsEl.textContent = 'Error creating replay'
      }
      replayBtn.disabled = false
    }
  </script>

  <footer class="site-footer">
    <small>&copy; <span id="year"></span> PiCam Lite</small>
  </footer>
</body>
</html>
